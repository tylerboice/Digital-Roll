<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Unknown </title></head><body>
<h1 id="yolov3-implemented-in-tensorflow-20">YoloV3 Implemented in TensorFlow 2.0</h1>
<p>This repo provides a clean implementation of YoloV3 in TensorFlow 2.0 using all the best practices.</p>
<h2 id="key-features">Key Features</h2>
<ul>
<li>[x] TensorFlow 2.0</li>
<li>[x] <code>yolov3</code> with pre-trained Weights</li>
<li>[x] <code>yolov3-tiny</code> with pre-trained Weights</li>
<li>[x] Inference example</li>
<li>[x] Transfer learning example</li>
<li>[x] Eager mode training with <code>tf.GradientTape</code></li>
<li>[x] Graph mode training with <code>model.fit</code></li>
<li>[x] Functional model with <code>tf.keras.layers</code></li>
<li>[x] Input pipeline using <code>tf.data</code></li>
<li>[x] Tensorflow Serving</li>
<li>[x] Vectorized transformations</li>
<li>[x] GPU accelerated</li>
<li>[x] Fully integrated with <code>absl-py</code> from <a href="https://abseil.io">abseil.io</a></li>
<li>[x] Clean implementation</li>
<li>[x] Following the best practices</li>
<li>[x] MIT License</li>
</ul>
<p><img alt="demo" src="https://raw.githubusercontent.com/zzh8829/yolov3-tf2/master/data/meme_out.jpg" />
<img alt="demo" src="https://raw.githubusercontent.com/zzh8829/yolov3-tf2/master/data/street_out.jpg" /></p>
<h2 id="usage">Usage</h2>
<h3 id="installation">Installation</h3>
<h4 id="conda-recommended">Conda (Recommended)</h4>
<p>```bash</p>
<h1 id="tensorflow-cpu">Tensorflow CPU</h1>
<p>conda env create -f conda-cpu.yml
conda activate yolov3-tf2-cpu</p>
<h1 id="tensorflow-gpu">Tensorflow GPU</h1>
<p>conda env create -f conda-gpu.yml
conda activate yolov3-tf2-gpu
```</p>
<h4 id="pip">Pip</h4>
<p><code>bash
pip install -r requirements.txt</code></p>
<h3 id="nvidia-driver-for-gpu">Nvidia Driver (For GPU)</h3>
<p>```bash</p>
<h1 id="ubuntu-1804">Ubuntu 18.04</h1>
<p>sudo apt-add-repository -r ppa:graphics-drivers/ppa
sudo apt install nvidia-driver-430</p>
<h1 id="windowsother">Windows/Other</h1>
<p>https://www.nvidia.com/Download/index.aspx
```</p>
<h3 id="convert-pre-trained-darknet-weights">Convert pre-trained Darknet weights</h3>
<p>```bash</p>
<h1 id="yolov3">yolov3</h1>
<p>wget https://pjreddie.com/media/files/yolov3.weights -O data/yolov3.weights
python convert.py</p>
<h1 id="yolov3-tiny">yolov3-tiny</h1>
<p>wget https://pjreddie.com/media/files/yolov3-tiny.weights -O data/yolov3-tiny.weights
python convert.py --weights ./data/yolov3-tiny.weights --output ./checkpoints/yolov3-tiny.tf --tiny
```</p>
<h3 id="detection">Detection</h3>
<p>```bash</p>
<h1 id="yolov3_1">yolov3</h1>
<p>python detect.py --image ./data/meme.jpg</p>
<h1 id="yolov3-tiny_1">yolov3-tiny</h1>
<p>python detect.py --weights ./checkpoints/yolov3-tiny.tf --tiny --image ./data/street.jpg</p>
<h1 id="webcam">webcam</h1>
<p>python detect_video.py --video 0</p>
<h1 id="video-file">video file</h1>
<p>python detect_video.py --video path_to_file.mp4 --weights ./checkpoints/yolov3-tiny.tf --tiny</p>
<h1 id="video-file-with-output">video file with output</h1>
<p>python detect_video.py --video path_to_file.mp4 --output ./output.avi
```</p>
<h3 id="training">Training</h3>
<p>I have created a complete tutorial on how to train from scratch using the VOC2012 Dataset.
See the documentation here https://github.com/zzh8829/yolov3-tf2/blob/master/docs/training_voc.md</p>
<p>For customzied training, you need to generate tfrecord following the TensorFlow Object Detection API.
For example you can use <a href="https://github.com/Microsoft/VoTT">Microsoft VOTT</a> to generate such dataset.
You can also use this <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/dataset_tools/create_pascal_tf_record.py">script</a> to create the pascal voc dataset.</p>
<p>Example commend line arguments for training
``` bash
python train.py --batch_size 8 --dataset ~/Data/voc2012.tfrecord --val_dataset ~/Data/voc2012_val.tfrecord --epochs 100 --mode eager_tf --transfer fine_tune</p>
<p>python train.py --batch_size 8 --dataset ~/Data/voc2012.tfrecord --val_dataset ~/Data/voc2012_val.tfrecord --epochs 100 --mode fit --transfer none</p>
<p>python train.py --batch_size 8 --dataset ~/Data/voc2012.tfrecord --val_dataset ~/Data/voc2012_val.tfrecord --epochs 100 --mode fit --transfer no_output</p>
<p>python train.py --batch_size 8 --dataset ~/Data/voc2012.tfrecord --val_dataset ~/Data/voc2012_val.tfrecord --epochs 10 --mode eager_fit --transfer fine_tune --weights ./checkpoints/yolov3-tiny.tf --tiny
```</p>
<h3 id="tensorflow-serving">Tensorflow Serving</h3>
<p>You can export the model to tf serving
```
python export_tfserving.py --output serving/yolov3/1/</p>
<h1 id="verify-tfserving-graph">verify tfserving graph</h1>
<p>saved_model_cli show --dir serving/yolov3/1/ --tag_set serve --signature_def serving_default
```</p>
<p>The inputs are preprocessed images (see <code>dataset.transform_iamges</code>)</p>
<p>outputs are
<code>yolo_nms_0: bounding boxes
yolo_nms_1: scores
yolo_nms_2: classes
yolo_nms_3: numbers of valid detections</code></p>
<h2 id="benchmark-no-training-yet">Benchmark (No Training Yet)</h2>
<p>Numbers are obtained with rough calculations from <code>detect_video.py</code></p>
<h3 id="macbook-pro-13-27ghz-i5">Macbook Pro 13 (2.7GHz i5)</h3>
<table>
<thead>
<tr>
<th>Detection</th>
<th>416x416</th>
<th>320x320</th>
<th>608x608</th>
</tr>
</thead>
<tbody>
<tr>
<td>YoloV3</td>
<td>1000ms</td>
<td>500ms</td>
<td>1546ms</td>
</tr>
<tr>
<td>YoloV3-Tiny</td>
<td>100ms</td>
<td>58ms</td>
<td>208ms</td>
</tr>
</tbody>
</table>
<h3 id="desktop-pc-gtx-970">Desktop PC (GTX 970)</h3>
<table>
<thead>
<tr>
<th>Detection</th>
<th>416x416</th>
<th>320x320</th>
<th>608x608</th>
</tr>
</thead>
<tbody>
<tr>
<td>YoloV3</td>
<td>74ms</td>
<td>57ms</td>
<td>129ms</td>
</tr>
<tr>
<td>YoloV3-Tiny</td>
<td>18ms</td>
<td>15ms</td>
<td>28ms</td>
</tr>
</tbody>
</table>
<h3 id="aws-g34xlarge-tesla-m60">AWS g3.4xlarge (Tesla M60)</h3>
<table>
<thead>
<tr>
<th>Detection</th>
<th>416x416</th>
<th>320x320</th>
<th>608x608</th>
</tr>
</thead>
<tbody>
<tr>
<td>YoloV3</td>
<td>66ms</td>
<td>50ms</td>
<td>123ms</td>
</tr>
<tr>
<td>YoloV3-Tiny</td>
<td>15ms</td>
<td>10ms</td>
<td>24ms</td>
</tr>
</tbody>
</table>
<h3 id="rtx-2070-credit-to-anarhist94">RTX 2070 (credit to @AnaRhisT94)</h3>
<table>
<thead>
<tr>
<th>Detection</th>
<th>416x416</th>
</tr>
</thead>
<tbody>
<tr>
<td>YoloV3 predict_on_batch</td>
<td>29-32ms</td>
</tr>
<tr>
<td>YoloV3 predict_on_batch + TensorRT</td>
<td>22-28ms</td>
</tr>
</tbody>
</table>
<p>Darknet version of YoloV3 at 416x416 takes 29ms on Titan X.
Considering Titan X has about double the benchmark of Tesla M60,
Performance-wise this implementation is pretty comparable.</p>
<h2 id="implementation-details">Implementation Details</h2>
<h3 id="eager-execution">Eager execution</h3>
<p>Great addition for existing TensorFlow experts.
Not very easy to use without some intermediate understanding of TensorFlow graphs.
It is annoying when you accidentally use incompatible features like tensor.shape[0]
or some sort of python control flow that works fine in eager mode, but
totally breaks down when you try to compile the model to graph.</p>
<h3 id="modelx-vs-modelpredictx">model(x) vs. model.predict(x)</h3>
<p>When calling model(x) directly, we are executing the graph in eager mode. For
<code>model.predict</code>, tf actually compiles the graph on the first run and then
execute in graph mode. So if you are only running the model once, <code>model(x)</code> is
faster since there is no compilation needed. Otherwise, <code>model.predict</code> or
using exported SavedModel graph is much faster (by 2x). For non real-time usage,
<code>model.predict_on_batch</code> is even faster as tested by @AnaRhisT94)</p>
<h3 id="gradienttape">GradientTape</h3>
<p>Extremely useful for debugging purpose, you can set breakpoints anywhere.
You can compile all the keras fitting functionalities with gradient tape using the
<code>run_eagerly</code> argument in model.compile. From my limited testing, all training methods
including GradientTape, keras.fit, eager or not yeilds similar performance. But graph
mode is still preferred since it's a tiny bit more efficient.</p>
<h3 id="tffunction">@tf.function</h3>
<p>@tf.function is very cool. It's like an in-between version of eager and graph.
You can step through the function by disabling tf.function and then gain
performance when you enable it in production. Important note, you should not
pass any non-tensor parameter to @tf.function, it will cause re-compilation
on every call. I am not sure whats the best way other than using globals.</p>
<h3 id="abslpy-abseil">absl.py (abseil)</h3>
<p>Absolutely amazing. If you don't know already, absl.py is officially used by
internal projects at Google. It standardizes application interface for Python
and many other languages. After using it within Google, I was so excited
to hear abseil going open source. It includes many decades of best practices
learned from creating large size scalable applications. I literally have
nothing bad to say about it, strongly recommend absl.py to everybody.</p>
<h3 id="loading-pre-trained-darknet-weights">Loading pre-trained Darknet weights</h3>
<p>very hard with pure functional API because the layer ordering is different in
tf.keras and darknet. The clean solution here is creating sub-models in keras.
Keras is not able to save nested model in h5 format properly, TF Checkpoint is
recommended since its offically supported by TensorFlow.</p>
<h3 id="tfkeraslayersbatchnormalization">tf.keras.layers.BatchNormalization</h3>
<p>It doesn't work very well for transfer learning. There are many articles and
github issues all over the internet. I used a simple hack to make it work nicer
on transfer learning with small batches.</p>
<h3 id="what-is-the-output-of-transform_targets">What is the output of transform_targets ???</h3>
<p>I know it's very confusion but the output is tuple of shape
<code>(
  [N, 13, 13, 3, 6],
  [N, 26, 26, 3, 6],
  [N, 52, 52, 3, 6]
)</code>
where N is the number of labels in batch and the last dimension "6" represents
<code>[x, y, w, h, obj, class]</code> of the bounding boxes.</p>
<h3 id="iou-and-score-threshold">IOU and Score Threshold</h3>
<p>the default threshold is 0.5 for both IOU and score, you can adjust them
according to your need by setting <code>--yolo_iou_threshold</code> and
<code>--yolo_score_threshold</code> flags</p>
<h3 id="maximum-number-of-boxes">Maximum number of boxes</h3>
<p>By default there can be maximum 100 bounding boxes per image, 
if for some reason you would like to have more boxes you can use the <code>--yolo_max_boxes</code> flag.</p>
<h3 id="nan-loss-training-failed-doesnt-converge">NAN Loss / Training Failed / Doesn't Converge</h3>
<p>Many people including me have succeeded in training, so the code definitely works
@LongxingTan in https://github.com/zzh8829/yolov3-tf2/issues/128 provided some of his insights summarized here:</p>
<ol>
<li>For nan loss, try to make learning rate smaller</li>
<li>Double check the format of your input data. Data input labelled by vott and labelImg is different. so make sure the input box is the right, and check carefully the format is <code>x1/width,y1/height,x2/width,y2/height</code> and <strong>NOT</strong> x1,y1,x2,y2, or x,y,w,h</li>
</ol>
<p>Make sure to visualize your custom dataset using this tool
<code>python tools/visualize_dataset.py --classes=./data/voc2012.names</code></p>
<p>It will output one random image from your dataset with label to <code>output.jpg</code>
Training definitely won't work if the rendered label doesn't look correct</p>
<h2 id="command-line-args-reference">Command Line Args Reference</h2>
<p>```bash
convert.py:
  --output: path to output
    (default: './checkpoints/yolov3.tf')
  --[no]tiny: yolov3 or yolov3-tiny
    (default: 'false')
  --weights: path to weights file
    (default: './data/yolov3.weights')
  --num_classes: number of classes in the model
    (default: '80')
    (an integer)</p>
<p>detect.py:
  --classes: path to classes file
    (default: './data/coco.names')
  --image: path to input image
    (default: './data/girl.png')
  --output: path to output image
    (default: './output.jpg')
  --[no]tiny: yolov3 or yolov3-tiny
    (default: 'false')
  --weights: path to weights file
    (default: './checkpoints/yolov3.tf')
  --num_classes: number of classes in the model
    (default: '80')
    (an integer)</p>
<p>detect_video.py:
  --classes: path to classes file
    (default: './data/coco.names')
  --video: path to input video (use 0 for cam)
    (default: './data/video.mp4')
  --output: path to output video (remember to set right codec for given format. e.g. XVID for .avi)
    (default: None)
  --output_format: codec used in VideoWriter when saving video to file
    (default: 'XVID)
  --[no]tiny: yolov3 or yolov3-tiny
    (default: 'false')
  --weights: path to weights file
    (default: './checkpoints/yolov3.tf')
  --num_classes: number of classes in the model
    (default: '80')
    (an integer)</p>
<p>train.py:
  --batch_size: batch size
    (default: '8')
    (an integer)
  --classes: path to classes file
    (default: './data/coco.names')
  --dataset: path to dataset
    (default: '')
  --epochs: number of epochs
    (default: '2')
    (an integer)
  --learning_rate: learning rate
    (default: '0.001')
    (a number)
  --mode: <fit|eager_fit|eager_tf>: fit: model.fit, eager_fit: model.fit(run_eagerly=True), eager_tf: custom GradientTape
    (default: 'fit')
  --num_classes: number of classes in the model
    (default: '80')
    (an integer)
  --size: image size
    (default: '416')
    (an integer)
  --[no]tiny: yolov3 or yolov3-tiny
    (default: 'false')
  --transfer: <none|darknet|no_output|frozen|fine_tune>: none: Training from scratch, darknet: Transfer darknet, no_output: Transfer all but output, frozen: Transfer and freeze all,
    fine_tune: Transfer all and freeze darknet only
    (default: 'none')
  --val_dataset: path to validation dataset
    (default: '')
  --weights: path to weights file
    (default: './checkpoints/yolov3.tf')
```</p>
<h2 id="change-log">Change Log</h2>
<h4 id="october-1-2019">October 1, 2019</h4>
<ul>
<li>Updated to Tensorflow to v2.0.0 Release</li>
</ul>
<h2 id="references">References</h2>
<p>It is pretty much impossible to implement this from the yolov3 paper alone. I had to reference the official (very hard to understand) and many un-official (many minor errors) repos to piece together the complete picture.</p>
<ul>
<li>https://github.com/pjreddie/darknet<ul>
<li>official yolov3 implementation</li>
</ul>
</li>
<li>https://github.com/AlexeyAB<ul>
<li>explinations of parameters</li>
</ul>
</li>
<li>https://github.com/qqwweee/keras-yolo3<ul>
<li>models</li>
<li>loss functions</li>
</ul>
</li>
<li>https://github.com/YunYang1994/tensorflow-yolov3<ul>
<li>data transformations</li>
<li>loss functions</li>
</ul>
</li>
<li>https://github.com/ayooshkathuria/pytorch-yolo-v3<ul>
<li>models</li>
</ul>
</li>
<li>https://github.com/broadinstitute/keras-resnet<ul>
<li>batch normalization fix</li>
</ul>
</li>
</ul>
</body></html>